## <a name="what-is"></a>Зачем нужен NgModule?

`NgModule` позволяет сгруппировать компоненты, директивы, пайпы и сервисы, чтобы упростить архитектуру приложения.

При этом каждая часть отвечает за конкретную функциональность.

<br/>

## <a name="lazy-load"></a>Что такое ленивая загрузка модулей?

Когда приложение разбито на модули, то с помощью т.н. "ленивой загрузки" (Lazy Loading) можно повысить его производительность, загружая модули только при необходимости.

Модули будут загружаться только при доступе к связанному с ними маршруту, что позволяет уменьшить первоначальный размер пакета.

Пример:

```typescript
 const routes: Routes = [
     { path: 'admin', loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule) }
   ];
```
После перехода с маршрута, связанного с лениво загружаемым модулем, Angular не гарантирует сразу автоматического удаления модуля из памяти. Однако, компоненты и их состояния, связанные с этим модулем, будут уничтожены, если они не используются нигде больше.

<br/>

## <a name="di"></a>Что такое внедрение зависимостей?

DI — это шаблон проектирования, в котором зависимости предоставляются классу, а не создаются им. Angular реализует DI с использованием иерархии инжекторов.

<br/>

## <a name="service"></a>Что такое сервис?

Сервис содержит повторно используемую бизнес-логику. Создать его можно с помощью CLI:

```bash
ng generate service serviceName
```

<br/>

## <a name="dip"></a>В чём заключается принцип инверсии зависимостей?

В том, что высокоуровневые сервисы не должны зависеть от низкоуровневых. Например, бизнес-логика не должна зависеть от доступа к данным.
Достигается это введением абстракции.

Пример:

```typescript
// Интерфейс для низкоуровневого сервиса
export interface IDataService {
  fetchData(): Observable<any>;
}

// Реализация низкоуровневого сервиса
@Injectable({
  providedIn: 'root',
})
export class ApiDataService implements IDataService {
  constructor(private http: HttpClient) {}

  fetchData(): Observable<any> {
    return this.http.get('https://api.example.com/data');
  }
}

// Высокоуровневый сервис, использующий абстракцию
@Injectable({
  providedIn: 'root',
})
export class BusinessLogicService {
  constructor(private dataService: IDataService) {}

  processData() {
    this.dataService.fetchData().subscribe(data => {
      // Обработка данных
    });
  }
}
```

<br/>

## <a name="di_hierarhy"></a>Кратко опишите иерархию инжекторов в Angular

Иерархия инжекторов управляет областью видимости зависимостей и временем их жизни. 

Уровни:

- Корневой инжектор (Root Injector):
  - Используется на уровне всего приложения.
  - В нём регистрируются сервисы, имеющие @Injectable({ providedIn: 'root' }) (синглетоны)

- Инжекторы модулей:
  - Используется на уроне NgModule.
  - В нём регистрируются сервисы указанные в свойстве providers конкретного модуля и доступные
  в модуле, а также в модулях, куда импортируется этот модуль.

- Инжекторы компонентов:
  - Используется на уровне компонента.
  - В нём регистрируются сервисы, указанные в свойстве providers компонента, и доступные только компоненту и его дочерним компонентам.

 Примеры: 

```typescript
@Injectable({ providedIn: 'root' })
export class MyGlobalService {}   //синглетон, доступен везде в приложении

@NgModule({
  providers: [MyModuleSpecificService]  //виден только в модуле MyFeatureModule
})
export class MyFeatureModule {}

@Component({
  providers: [MyComponentService]  //виден только в компоненте
})
export class MyComponent {}
```

<br/>

## <a name="di_rereg"></a>В чём заключается принцип переопределения зависимостей?

Если сервис зарегистрирован корневым инжектором, и тот же сервис указывается в providers секции модуля или компонента, то Angular создаст новый экземпляр сервиса для этого более локального контекста.
Это означает, что в пределах этого компонента и его дочерних компонентов этот новый экземпляр будет использоваться вместо глобального singleton.

<br/>